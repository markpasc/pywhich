#!/usr/bin/env python

import logging
from optparse import OptionParser
import os
import sys

DOT = '.'

log = logging.getLogger('pywhich')


class ModuleNotFound(Exception):
    pass


def identify_module(arg):
    try:
        __import__(arg)
    except Exception, exc:
        raise ModuleNotFound("%s: %s" % (type(exc).__name__, str(exc)))

    mod = sys.modules[arg]
    filename = mod.__file__

    if filename.endswith('.pyc') or filename.endswith('.pyo'):
        sourcefile = filename[:-1]
        if os.access(sourcefile, os.F_OK):
            return sourcefile

    return filename


def identify_modules(*args, **kwargs):
    if len(args) == 1:
        path_template = "%(file)s"
        error_template = "Module '%(mod)s' not found (%(error)s)"
    else:
        path_template = "%(mod)s: %(file)s"
        error_template = "%(mod)s: not found (%(error)s)"

    for modulename in args:
        try:
            filepath = identify_module(modulename, **kwargs)
        except ModuleNotFound, exc:
            print error_template % {
                'mod': modulename,
                'error': str(exc),
            }
        else:
            print path_template % {
                'mod': modulename,
                'file': filepath
            }


def main(argv=None):
    if argv is None:
        argv = sys.argv

    parser = OptionParser()
    parser.add_option('-v', '--verbose', dest="verbose", action="count",
        default=2, help="be chattier (stackable)")
    def quiet(option, opt_str, value, parser):
        parser.values.verbose -= 1
    parser.add_option('-q', '--quiet', action="callback", callback=quiet,
        help="be less chatty (stackable)")
    opts, args = parser.parse_args()

    log_levels = (logging.CRITICAL, logging.ERROR, logging.WARNING, logging.INFO, logging.DEBUG)
    logging.basicConfig()
    log.setLevel(log_levels[opts.verbose % 5])

    identify_modules(*args)

    return 0


if __name__ == '__main__':
    sys.exit(main())

